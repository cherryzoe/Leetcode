
由于斐波纳挈数列是以兔子的繁殖引入的，因此也叫“兔子数列”。
它指的是这样一个数列：0,1,1,2,3,5,8,13......
从这组数可以很明显看出这样一个规律：从第三个数开始，后边一个数一定是在其之前两个数的和。
在数学上，斐波纳挈数列可以以这样的公式表示：F(0) = 0
F(1) = 1 F(n) = F(n-1) + F(n-2),(n>=2)

Fibonacci Array solution:
1. recursive time complexity 2^n
  def fib(self, n):
      if n < 2:
          return n
       return fib(n-1) + fib(n-2)
这样的递归算法虽然只有简单的几行，但是效率却很低。为什么呢？我们可以分析其递归调用的时间复杂度：

时间复杂度 ----- O(2^N)

由于使用递归时，其执行步骤是：要得到后一个数之前必须先计算出之前的两个数，即在每个递归调用时都会触发另外两个递归调用，例如：要得到F(10)之前得先得到F(9)、F(8)，那么得到F(9)之前得先得到F(8)、F(7)......如此递归下去

2. Iterative with n space
创建一个数组，每次将前两个数相加后直接赋给后一个数。这样的话，有N个数就创建一个包含N个数的一维数组，所以空间复杂度为O(N)；由于只需从头向尾遍历一边，时间复杂度为O(N)
def fib2(self, n):
    n = 16
    f = [0] * n
    f[0] = 0
    f[1] = 1
    for i in range(2,n):
        f[i] = f[i-1] + f[i-2]
    print f


3. Iterative with 1 space
借助两个变量 a 和 b ，每次将 a 和 b 相加后赋给 c ，再将 b 赋给 a ，c 赋给 b，如此循环。
def fib3(self, n):
    n = 10
    a, b = 0, 1
    for i in range(2,n):
        c = a + b
        a = b
        b = c
        print c
